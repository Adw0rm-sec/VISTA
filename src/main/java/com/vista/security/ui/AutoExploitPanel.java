package com.vista.security.ui;

import burp.*;
import com.vista.security.core.*;
import com.vista.security.service.*;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Real-time Auto-Exploit Panel with Repeater-style interface.
 * Shows live request/response data during exploitation.
 */
public class AutoExploitPanel extends JPanel {

    private final IBurpExtenderCallbacks callbacks;
    private final IExtensionHelpers helpers;
    private final AutoExploitEngine exploitEngine;

    // Request/Response display
    private final JTextArea requestArea = new JTextArea();
    private final JTextArea responseArea = new JTextArea();
    private final JTextArea aiChatArea = new JTextArea();
    private final JTextField promptField = new JTextField();

    // Results table
    private final DefaultTableModel resultsModel;
    private final JTable resultsTable;
    private final List<AutoExploitEngine.ExploitResult> allResults = new ArrayList<>();

    // Status
    private final JLabel statusLabel = new JLabel("Ready - Send a request to start");
    private final JProgressBar progressBar = new JProgressBar();
    private final JLabel statsLabel = new JLabel("Requests: 0 | Findings: 0");

    // Current request
    private IHttpRequestResponse currentRequest;
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    // AI Service
    private AIServiceConfig aiConfig;

    public AutoExploitPanel(IBurpExtenderCallbacks callbacks) {
        this.callbacks = callbacks;
        this.helpers = callbacks.getHelpers();
        this.exploitEngine = new AutoExploitEngine(callbacks);

        // Initialize table
        String[] columns = {"#", "Payload", "Status", "Length", "Time", "Finding"};
        this.resultsModel = new DefaultTableModel(columns, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        this.resultsTable = new JTable(resultsModel);

        setLayout(new BorderLayout(8, 8));
        setBorder(new EmptyBorder(8, 8, 8, 8));
        buildUI();
    }

    private void buildUI() {
        // Top: AI Prompt bar (like Burp AI)
        JPanel promptPanel = buildPromptPanel();

        // Center: Split between results table and request/response
        JSplitPane centerSplit = buildCenterPanel();

        // Bottom: Status bar
        JPanel statusPanel = buildStatusPanel();

        add(promptPanel, BorderLayout.NORTH);
        add(centerSplit, BorderLayout.CENTER);
        add(statusPanel, BorderLayout.SOUTH);
    }

    private JPanel buildPromptPanel() {
        JPanel panel = new JPanel(new BorderLayout(8, 4));
        panel.setBorder(BorderFactory.createTitledBorder("ü§ñ VISTA AI - Describe what you want to test"));

        // Prompt input
        promptField.setFont(new Font(Font.SANS_SERIF, Font.PLAIN, 14));
        installPlaceholder(promptField, "e.g., 'Bypass the input validation on the email parameter' or 'Test for SQL injection'");

        // Buttons
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 4, 0));
        JButton runButton = new JButton("üöÄ Run VISTA AI");
        JButton stopButton = new JButton("‚èπ Stop");
        JButton clearButton = new JButton("üóë Clear");

        runButton.setFont(runButton.getFont().deriveFont(Font.BOLD));
        runButton.setBackground(new Color(46, 204, 113));

        runButton.addActionListener(e -> runAIExploit());
        stopButton.addActionListener(e -> stopExploit());
        clearButton.addActionListener(e -> clearResults());

        buttonPanel.add(clearButton);
        buttonPanel.add(stopButton);
        buttonPanel.add(runButton);

        // Quick prompts
        JPanel quickPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 4, 0));
        String[] quickPrompts = {
            "Bypass validation", "Test SQLi", "Test XSS", "Auth bypass", "Find IDOR"
        };
        for (String prompt : quickPrompts) {
            JButton btn = new JButton(prompt);
            btn.setFont(btn.getFont().deriveFont(10f));
            btn.addActionListener(e -> {
                promptField.setText(prompt + " on this request");
                runAIExploit();
            });
            quickPanel.add(btn);
        }

        JPanel topRow = new JPanel(new BorderLayout(8, 0));
        topRow.add(promptField, BorderLayout.CENTER);
        topRow.add(buttonPanel, BorderLayout.EAST);

        panel.add(topRow, BorderLayout.CENTER);
        panel.add(quickPanel, BorderLayout.SOUTH);

        return panel;
    }

    private JSplitPane buildCenterPanel() {
        // Left: Results table
        JPanel tablePanel = new JPanel(new BorderLayout(4, 4));
        tablePanel.setBorder(BorderFactory.createTitledBorder("üìä Live Results"));

        resultsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        resultsTable.getColumnModel().getColumn(0).setPreferredWidth(40);  // #
        resultsTable.getColumnModel().getColumn(1).setPreferredWidth(250); // Payload
        resultsTable.getColumnModel().getColumn(2).setPreferredWidth(60);  // Status
        resultsTable.getColumnModel().getColumn(3).setPreferredWidth(70);  // Length
        resultsTable.getColumnModel().getColumn(4).setPreferredWidth(60);  // Time
        resultsTable.getColumnModel().getColumn(5).setPreferredWidth(150); // Finding

        // Color code findings
        resultsTable.setDefaultRenderer(Object.class, new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                    boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (!isSelected && row < allResults.size()) {
                    AutoExploitEngine.ExploitResult result = allResults.get(row);
                    if (result.potentialBypass) {
                        c.setBackground(new Color(255, 200, 200)); // Light red for findings
                    } else {
                        c.setBackground(row % 2 == 0 ? Color.WHITE : new Color(245, 245, 245));
                    }
                }
                return c;
            }
        });

        resultsTable.getSelectionModel().addListSelectionListener(e -> {
            if (!e.getValueIsAdjusting()) {
                showSelectedResult();
            }
        });

        tablePanel.add(new JScrollPane(resultsTable), BorderLayout.CENTER);

        // Right: Request/Response/AI Chat tabs
        JTabbedPane detailTabs = new JTabbedPane();

        Font monoFont = new Font(Font.MONOSPACED, Font.PLAIN, 12);
        requestArea.setFont(monoFont);
        responseArea.setFont(monoFont);
        aiChatArea.setFont(monoFont);
        requestArea.setEditable(false);
        responseArea.setEditable(false);
        aiChatArea.setEditable(false);

        detailTabs.addTab("Request", new JScrollPane(requestArea));
        detailTabs.addTab("Response", new JScrollPane(responseArea));
        detailTabs.addTab("AI Analysis", new JScrollPane(aiChatArea));

        JSplitPane split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, tablePanel, detailTabs);
        split.setResizeWeight(0.5);

        return split;
    }

    private JPanel buildStatusPanel() {
        JPanel panel = new JPanel(new BorderLayout(8, 0));
        panel.setBorder(new EmptyBorder(4, 0, 0, 0));

        progressBar.setPreferredSize(new Dimension(200, 20));
        progressBar.setStringPainted(true);

        panel.add(statusLabel, BorderLayout.WEST);
        panel.add(progressBar, BorderLayout.CENTER);
        panel.add(statsLabel, BorderLayout.EAST);

        return panel;
    }

    /**
     * Set the request to exploit (called from context menu).
     */
    public void setRequest(IHttpRequestResponse request) {
        this.currentRequest = request;
        if (request != null) {
            String reqText = HttpMessageParser.requestToText(helpers, request.getRequest());
            requestArea.setText(reqText);
            requestArea.setCaretPosition(0);

            if (request.getResponse() != null) {
                String respText = HttpMessageParser.responseToText(helpers, request.getResponse());
                responseArea.setText(respText);
                responseArea.setCaretPosition(0);
            }

            statusLabel.setText("Request loaded - Enter prompt and click Run");
        }
    }

    /**
     * Run AI-driven exploit based on user prompt.
     */
    private void runAIExploit() {
        if (currentRequest == null) {
            JOptionPane.showMessageDialog(this, "No request loaded. Right-click a request and send to VISTA AI.",
                "No Request", JOptionPane.WARNING_MESSAGE);
            return;
        }

        if (isRunning.get()) {
            JOptionPane.showMessageDialog(this, "Exploit already running. Click Stop first.",
                "Already Running", JOptionPane.WARNING_MESSAGE);
            return;
        }

        String prompt = promptField.getText().trim();
        if (prompt.isEmpty() || prompt.startsWith("e.g.,")) {
            prompt = "Analyze this request and test for common vulnerabilities with bypass techniques";
        }

        isRunning.set(true);
        clearResults();

        final String userPrompt = prompt;

        new Thread(() -> {
            try {
                // Step 1: Ask AI to analyze and suggest exploit strategy
                updateStatus("ü§ñ Asking AI to analyze request...");
                appendAIChat("USER", userPrompt);

                String aiResponse = askAIForExploitPlan(userPrompt);
                appendAIChat("VISTA AI", aiResponse);

                // Step 2: Parse AI response to get exploit config
                AutoExploitEngine.ExploitConfig config = parseAIResponse(aiResponse);
                
                if (config == null) {
                    updateStatus("AI couldn't determine exploit strategy. Using generic approach.");
                    config = createGenericConfig();
                }

                appendAIChat("SYSTEM", "Starting exploit: " + config.exploitType + 
                    " on parameter: " + config.targetParameter);

                // Step 3: Run exploit with real-time updates
                updateStatus("üöÄ Running exploit: " + config.exploitType);
                progressBar.setMaximum(config.maxPayloads);

                final AutoExploitEngine.ExploitConfig finalConfig = config;
                int[] count = {0};
                int[] findings = {0};

                AutoExploitEngine.ExploitSummary summary = exploitEngine.runExploit(
                    currentRequest,
                    finalConfig,
                    status -> SwingUtilities.invokeLater(() -> updateStatus(status)),
                    result -> SwingUtilities.invokeLater(() -> {
                        count[0]++;
                        addResultToTable(result, count[0]);
                        progressBar.setValue(count[0]);

                        if (result.potentialBypass) {
                            findings[0]++;
                            appendAIChat("üéØ FINDING", "Potential bypass with: " + result.payload +
                                "\nReason: " + result.bypassIndicator);
                        }

                        statsLabel.setText("Requests: " + count[0] + " | Findings: " + findings[0]);
                    })
                );

                // Step 4: Ask AI to summarize findings
                if (summary.hasFindings()) {
                    updateStatus("ü§ñ AI analyzing findings...");
                    String findingsSummary = askAIToSummarizeFindings(summary);
                    appendAIChat("VISTA AI", findingsSummary);
                }

                SwingUtilities.invokeLater(() -> {
                    updateStatus("‚úÖ Complete - " + summary.potentialBypasses.size() + " potential bypass(es) found");
                    progressBar.setValue(progressBar.getMaximum());
                });

            } catch (Exception e) {
                SwingUtilities.invokeLater(() -> {
                    updateStatus("‚ùå Error: " + e.getMessage());
                    appendAIChat("ERROR", e.getMessage());
                });
                callbacks.printError("Auto-exploit error: " + e);
            } finally {
                isRunning.set(false);
            }
        }, "VISTA-AI-Exploit").start();
    }

    private String askAIForExploitPlan(String userPrompt) {
        try {
            String requestText = HttpMessageParser.requestToText(helpers, currentRequest.getRequest());
            String responseText = currentRequest.getResponse() != null 
                ? HttpMessageParser.responseToText(helpers, currentRequest.getResponse()) : "(no response)";

            String systemPrompt = """
                You are VISTA AI, an expert penetration testing assistant.
                Analyze the HTTP request and user's goal, then provide an exploit plan.
                
                RESPOND IN THIS EXACT FORMAT:
                EXPLOIT_TYPE: [XSS|SQLi|Command|Path|Auth|Generic]
                TARGET_PARAMETER: [parameter name to test]
                STRATEGY: [brief description of approach]
                PAYLOADS: [optional comma-separated custom payloads]
                
                Be specific about which parameter to target based on the request.
                """;

            String userMessage = "User request: " + userPrompt + "\n\nHTTP Request:\n" + 
                truncate(requestText, 4000) + "\n\nHTTP Response:\n" + truncate(responseText, 2000);

            return callAI(systemPrompt, userMessage);
        } catch (Exception e) {
            return "Error analyzing request: " + e.getMessage() + "\nUsing generic exploit approach.";
        }
    }

    private String askAIToSummarizeFindings(AutoExploitEngine.ExploitSummary summary) {
        try {
            StringBuilder findingsText = new StringBuilder();
            findingsText.append("Found ").append(summary.potentialBypasses.size()).append(" potential bypasses:\n\n");
            
            for (AutoExploitEngine.ExploitResult r : summary.potentialBypasses) {
                findingsText.append("- Payload: ").append(r.payload).append("\n");
                findingsText.append("  Indicator: ").append(r.bypassIndicator).append("\n");
                findingsText.append("  Response: ").append(r.statusCode).append(" (").append(r.responseLength).append(" bytes)\n\n");
            }

            String systemPrompt = """
                You are VISTA AI. Analyze these exploit findings and provide:
                1. Severity assessment (Critical/High/Medium/Low)
                2. Explanation of why each bypass worked
                3. Recommended next steps for exploitation
                4. Remediation suggestions
                
                Be concise but thorough.
                """;

            return callAI(systemPrompt, findingsText.toString());
        } catch (Exception e) {
            return "Could not generate AI summary: " + e.getMessage();
        }
    }

    private AutoExploitEngine.ExploitConfig parseAIResponse(String aiResponse) {
        AutoExploitEngine.ExploitConfig config = new AutoExploitEngine.ExploitConfig();
        
        // Parse EXPLOIT_TYPE
        String type = extractField(aiResponse, "EXPLOIT_TYPE");
        if (type != null) {
            config.exploitType = type.toUpperCase().trim();
        } else {
            config.exploitType = "Generic";
        }

        // Parse TARGET_PARAMETER
        String param = extractField(aiResponse, "TARGET_PARAMETER");
        if (param != null && !param.isBlank()) {
            config.targetParameter = param.trim();
        } else {
            // Try to find first parameter in request
            String reqText = HttpMessageParser.requestToText(helpers, currentRequest.getRequest());
            List<String> params = extractParameterNames(reqText);
            config.targetParameter = params.isEmpty() ? "input" : params.get(0);
        }

        // Parse custom payloads
        String payloads = extractField(aiResponse, "PAYLOADS");
        if (payloads != null && !payloads.isBlank()) {
            for (String p : payloads.split(",")) {
                if (!p.trim().isEmpty()) {
                    config.customPayloads.add(p.trim());
                }
            }
        }

        config.maxPayloads = 30;
        config.delayMs = 100;

        return config;
    }

    private AutoExploitEngine.ExploitConfig createGenericConfig() {
        AutoExploitEngine.ExploitConfig config = new AutoExploitEngine.ExploitConfig();
        config.exploitType = "Generic";
        config.maxPayloads = 30;
        config.delayMs = 100;

        String reqText = HttpMessageParser.requestToText(helpers, currentRequest.getRequest());
        List<String> params = extractParameterNames(reqText);
        config.targetParameter = params.isEmpty() ? "input" : params.get(0);

        return config;
    }

    private String extractField(String text, String field) {
        String pattern = field + ":";
        int idx = text.indexOf(pattern);
        if (idx < 0) {
            pattern = field.toLowerCase() + ":";
            idx = text.indexOf(pattern);
        }
        if (idx < 0) return null;

        int start = idx + pattern.length();
        int end = text.indexOf("\n", start);
        if (end < 0) end = text.length();

        return text.substring(start, end).trim();
    }

    private List<String> extractParameterNames(String requestText) {
        List<String> params = new ArrayList<>();
        
        // URL parameters
        String firstLine = requestText.split("\r?\n")[0];
        int queryStart = firstLine.indexOf('?');
        int pathEnd = firstLine.lastIndexOf(" HTTP");
        if (queryStart > 0 && pathEnd > queryStart) {
            String query = firstLine.substring(queryStart + 1, pathEnd);
            for (String pair : query.split("&")) {
                int eq = pair.indexOf('=');
                if (eq > 0) params.add(pair.substring(0, eq));
            }
        }
        
        // Body parameters
        int bodyStart = requestText.indexOf("\r\n\r\n");
        if (bodyStart > 0) {
            String body = requestText.substring(bodyStart + 4);
            for (String pair : body.split("&")) {
                int eq = pair.indexOf('=');
                if (eq > 0) {
                    String name = pair.substring(0, eq).trim();
                    if (!name.isEmpty() && !params.contains(name)) params.add(name);
                }
            }
            // JSON
            java.util.regex.Matcher m = java.util.regex.Pattern.compile("\"([^\"]+)\"\\s*:").matcher(body);
            while (m.find()) {
                String name = m.group(1);
                if (!params.contains(name)) params.add(name);
            }
        }
        
        return params;
    }

    private String callAI(String systemPrompt, String userMessage) throws Exception {
        // Try to get AI config from parent panel or use defaults
        // For now, use a simple approach - this should be connected to main settings
        
        // Check if OpenAI key is available via system property or env
        String apiKey = System.getenv("OPENAI_API_KEY");
        if (apiKey == null || apiKey.isBlank()) {
            apiKey = System.getProperty("vista.openai.key", "");
        }
        
        if (apiKey.isBlank()) {
            return "AI not configured. Please set up AI provider in VISTA settings.\n\n" +
                   "Proceeding with automatic exploit detection based on response analysis.";
        }

        OpenAIService.Configuration config = new OpenAIService.Configuration();
        config.setApiKey(apiKey);
        config.setModel("gpt-4o-mini");
        config.setTemperature(0.7);

        return new OpenAIService(config).ask(systemPrompt, userMessage);
    }

    private void addResultToTable(AutoExploitEngine.ExploitResult result, int index) {
        allResults.add(result);
        resultsModel.addRow(new Object[]{
            index,
            truncate(result.payload, 50),
            result.statusCode,
            result.responseLength,
            result.responseTime + "ms",
            result.potentialBypass ? "üéØ " + truncate(result.bypassIndicator, 30) : "-"
        });

        // Auto-scroll to latest
        resultsTable.scrollRectToVisible(resultsTable.getCellRect(resultsModel.getRowCount() - 1, 0, true));
    }

    private void showSelectedResult() {
        int row = resultsTable.getSelectedRow();
        if (row < 0 || row >= allResults.size()) return;

        AutoExploitEngine.ExploitResult result = allResults.get(row);

        if (result.requestResponse != null) {
            if (result.requestResponse.getRequest() != null) {
                requestArea.setText(HttpMessageParser.requestToText(helpers, result.requestResponse.getRequest()));
                requestArea.setCaretPosition(0);
            }
            if (result.requestResponse.getResponse() != null) {
                responseArea.setText(HttpMessageParser.responseToText(helpers, result.requestResponse.getResponse()));
                responseArea.setCaretPosition(0);
            }
        }
    }

    private void stopExploit() {
        if (isRunning.get()) {
            exploitEngine.stop();
            updateStatus("‚èπ Stopped by user");
            isRunning.set(false);
        }
    }

    private void clearResults() {
        allResults.clear();
        resultsModel.setRowCount(0);
        requestArea.setText("");
        responseArea.setText("");
        aiChatArea.setText("");
        statsLabel.setText("Requests: 0 | Findings: 0");
        progressBar.setValue(0);
    }

    private void updateStatus(String status) {
        SwingUtilities.invokeLater(() -> statusLabel.setText(status));
    }

    private void appendAIChat(String speaker, String message) {
        SwingUtilities.invokeLater(() -> {
            aiChatArea.append("[" + speaker + "]\n" + message + "\n\n");
            aiChatArea.setCaretPosition(aiChatArea.getDocument().getLength());
        });
    }

    private String truncate(String s, int max) {
        if (s == null) return "";
        return s.length() > max ? s.substring(0, max) + "..." : s;
    }

    private void installPlaceholder(JTextField field, String placeholder) {
        Color hintColor = new Color(150, 150, 150);
        Color normalColor = field.getForeground();

        field.setForeground(hintColor);
        field.setText(placeholder);

        field.addFocusListener(new FocusAdapter() {
            @Override
            public void focusGained(FocusEvent e) {
                if (field.getForeground().equals(hintColor)) {
                    field.setText("");
                    field.setForeground(normalColor);
                }
            }

            @Override
            public void focusLost(FocusEvent e) {
                if (field.getText().isBlank()) {
                    field.setForeground(hintColor);
                    field.setText(placeholder);
                }
            }
        });

        // Enter to run
        field.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    runAIExploit();
                }
            }
        });
    }

    /**
     * Configuration holder for AI service.
     */
    public static class AIServiceConfig {
        public String provider;
        public String apiKey;
        public String model;
        public String endpoint;
    }

    public void setAIConfig(AIServiceConfig config) {
        this.aiConfig = config;
    }
}
