package com.vista.security.core;

import burp.*;
import com.vista.security.service.AzureAIService;
import com.vista.security.service.OpenAIService;

import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * AI-Powered Exploit Engine - Acts like a professional offensive security expert.
 * 
 * Workflow:
 * 1. AI analyzes the specific request to understand context, parameters, and potential vulnerabilities
 * 2. AI generates targeted payloads specific to THIS request (not generic payloads)
 * 3. Tests each payload and collects detailed response data
 * 4. AI analyzes all results to determine exploitability
 * 5. If not exploitable: AI provides detailed technical reasoning with evidence
 */
public class AIExploitEngine {

    private final IBurpExtenderCallbacks callbacks;
    private final IExtensionHelpers helpers;
    private final AtomicBoolean shouldStop = new AtomicBoolean(false);
    
    private static final int MAX_ITERATIONS = 3; // Max rounds of payload generation
    
    // Lazy-initialized headless browser verifier for XSS confirmation
    private static HeadlessBrowserVerifier browserVerifier;

    public AIExploitEngine(IBurpExtenderCallbacks callbacks) {
        this.callbacks = callbacks;
        this.helpers = callbacks.getHelpers();
    }
    
    /**
     * Get or create the headless browser verifier (singleton).
     */
    private synchronized HeadlessBrowserVerifier getBrowserVerifier() {
        if (browserVerifier == null) {
            browserVerifier = new HeadlessBrowserVerifier();
        }
        return browserVerifier;
    }
    
    /**
     * Check if headless browser verification is available.
     */
    public boolean isBrowserVerificationAvailable() {
        return getBrowserVerifier().isAvailable();
    }
    
    /**
     * Get browser verification status message.
     */
    public String getBrowserVerificationStatus() {
        return getBrowserVerifier().getStatusMessage();
    }

    public boolean isConfigured() {
        return AIConfigManager.getInstance().isConfigured();
    }

    public void stop() {
        shouldStop.set(true);
    }

    public static class AIExploitResult {
        public final String phase;
        public final String message;
        public final String payload;
        public final byte[] request;
        public final byte[] response;
        public final int statusCode;
        public final int responseLength;
        public final boolean isExploitable;
        public final String evidence;

        public AIExploitResult(String phase, String message, String payload,
                              byte[] request, byte[] response, int statusCode,
                              int responseLength, boolean isExploitable, String evidence) {
            this.phase = phase;
            this.message = message;
            this.payload = payload;
            this.request = request;
            this.response = response;
            this.statusCode = statusCode;
            this.responseLength = responseLength;
            this.isExploitable = isExploitable;
            this.evidence = evidence;
        }
    }

    /**
     * Run AI-powered exploit like a professional pentester.
     */
    public void runExploit(IHttpRequestResponse baseRequest, String userPrompt,
                          Consumer<AIExploitResult> resultCallback) throws Exception {
        
        if (!isConfigured()) {
            throw new IllegalStateException("AI not configured. Please configure in Settings tab.");
        }

        shouldStop.set(false);
        
        String requestText = new String(baseRequest.getRequest(), java.nio.charset.StandardCharsets.UTF_8);
        String responseText = baseRequest.getResponse() != null 
            ? new String(baseRequest.getResponse(), java.nio.charset.StandardCharsets.UTF_8) : "";
        
        IHttpService service = baseRequest.getHttpService();
        String host = service != null ? service.getHost() : extractHost(requestText);
        int port = service != null ? service.getPort() : 80;
        boolean https = service != null && "https".equalsIgnoreCase(service.getProtocol());

        List<TestResult> allTestResults = new ArrayList<>();
        boolean exploitFound = false;
        int iteration = 0;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 1: Deep Analysis - Understand the request like an expert
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        resultCallback.accept(new AIExploitResult("RECON", 
            "üîç Analyzing request context, parameters, and application behavior...", 
            null, null, null, 0, 0, false, null));

        String analysisPrompt = buildExpertAnalysisPrompt(userPrompt, requestText, responseText);
        String analysis = callAI(analysisPrompt);
        
        resultCallback.accept(new AIExploitResult("RECON", analysis, 
            null, null, null, 0, 0, false, null));

        if (shouldStop.get()) return;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 2: Iterative Exploitation - Try multiple approaches
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        while (iteration < MAX_ITERATIONS && !exploitFound && !shouldStop.get()) {
            iteration++;
            
            resultCallback.accept(new AIExploitResult("EXPLOIT", 
                "üéØ Round " + iteration + "/" + MAX_ITERATIONS + ": Generating targeted payloads...", 
                null, null, null, 0, 0, false, null));

            // Generate payloads based on analysis and previous results
            String payloadPrompt = buildPayloadGenerationPrompt(userPrompt, requestText, responseText, 
                analysis, allTestResults, iteration);
            String payloadResponse = callAI(payloadPrompt);
            
            resultCallback.accept(new AIExploitResult("EXPLOIT", 
                "AI Strategy:\n" + truncate(payloadResponse, 500), 
                null, null, null, 0, 0, false, null));

            List<PayloadInfo> payloads = parsePayloads(payloadResponse, requestText);
            
            if (payloads.isEmpty()) {
                resultCallback.accept(new AIExploitResult("EXPLOIT", 
                    "‚ö†Ô∏è No specific payloads generated. Trying alternative approach...", 
                    null, null, null, 0, 0, false, null));
                continue;
            }

            // Test each payload
            for (int i = 0; i < payloads.size() && !shouldStop.get() && !exploitFound; i++) {
                PayloadInfo payload = payloads.get(i);
                
                resultCallback.accept(new AIExploitResult("TESTING", 
                    "Testing [" + (i + 1) + "/" + payloads.size() + "]: " + payload.description, 
                    payload.value, null, null, 0, 0, false, null));

                TestResult result = executePayload(baseRequest, payload, host, port, https);
                allTestResults.add(result);

                // Build detailed status
                String status = buildTestStatus(result);
                resultCallback.accept(new AIExploitResult("TESTING", status,
                    payload.value, result.request, result.response, 
                    result.statusCode, result.responseLength, false, null));

                // AI-based verification: Let AI analyze if this is a REAL vulnerability
                // This prevents false positives from encoded output, filtered responses, etc.
                if (hasInterestingResponse(result, payload)) {
                    
                    // For XSS payloads, use headless browser for definitive verification
                    if (isXSSPayload(payload.value)) {
                        HeadlessBrowserVerifier browserVerifier = getBrowserVerifier();
                        if (browserVerifier.isAvailable()) {
                            resultCallback.accept(new AIExploitResult("VERIFY", 
                                "üåê Verifying XSS in headless browser...", 
                                payload.value, null, null, 0, 0, false, null));
                            
                            String marker = extractXSSMarker(payload.value);
                            String htmlResponse = extractHtmlBody(result.responseText);
                            if (result.redirectedResponseText != null) {
                                htmlResponse += result.redirectedResponseText;
                            }
                            
                            HeadlessBrowserVerifier.VerificationResult browserResult = 
                                browserVerifier.verifyXSS(htmlResponse, payload.value, marker);
                            
                            if (browserResult.executed) {
                                exploitFound = true;
                                String evidence = "üåê BROWSER VERIFICATION: " + browserResult.message;
                                if (browserResult.evidence != null) {
                                    evidence += "\n\n" + browserResult.evidence;
                                }
                                resultCallback.accept(new AIExploitResult("SUCCESS", 
                                    "üéØ XSS CONFIRMED - Payload executed in browser!\n\n" + evidence,
                                    payload.value, result.request, result.response, 
                                    result.statusCode, result.responseLength, true, evidence));
                                continue;
                            } else {
                                resultCallback.accept(new AIExploitResult("VERIFY", 
                                    "üåê Browser: " + browserResult.message,
                                    payload.value, null, null, 0, 0, false, null));
                                // Continue to AI verification as backup
                            }
                        }
                    }
                    
                    // AI verification (for non-XSS or when browser not available)
                    resultCallback.accept(new AIExploitResult("VERIFY", 
                        "üî¨ AI verifying if payload actually executed...", 
                        payload.value, null, null, 0, 0, false, null));
                    
                    String verificationResult = verifyExploitWithAI(result, payload, userPrompt);
                    
                    if (verificationResult.toLowerCase().contains("confirmed") || 
                        verificationResult.toLowerCase().contains("vulnerable") ||
                        verificationResult.toLowerCase().contains("successfully executed")) {
                        
                        // Double check it's not saying "not confirmed" or "not vulnerable"
                        if (!verificationResult.toLowerCase().contains("not confirmed") &&
                            !verificationResult.toLowerCase().contains("not vulnerable") &&
                            !verificationResult.toLowerCase().contains("false positive") &&
                            !verificationResult.toLowerCase().contains("encoded") &&
                            !verificationResult.toLowerCase().contains("sanitized")) {
                            
                            exploitFound = true;
                            resultCallback.accept(new AIExploitResult("SUCCESS", 
                                "üéØ VULNERABILITY CONFIRMED BY AI!\n\n" + verificationResult,
                                payload.value, result.request, result.response, 
                                result.statusCode, result.responseLength, true, 
                                verificationResult));
                        } else {
                            resultCallback.accept(new AIExploitResult("VERIFY", 
                                "‚ùå AI determined this is NOT exploitable:\n" + truncate(verificationResult, 300),
                                payload.value, null, null, 0, 0, false, null));
                        }
                    } else {
                        resultCallback.accept(new AIExploitResult("VERIFY", 
                            "‚ùå " + truncate(verificationResult, 200),
                            payload.value, null, null, 0, 0, false, null));
                    }
                }

                Thread.sleep(100);
            }
        }

        if (shouldStop.get()) return;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 3: Expert Analysis of Results
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if (!exploitFound) {
            resultCallback.accept(new AIExploitResult("ANALYSIS", 
                "üî¨ AI analyzing all test results to determine exploitability...", 
                null, null, null, 0, 0, false, null));

            String verdictPrompt = buildVerdictPrompt(userPrompt, requestText, allTestResults);
            String verdict = callAI(verdictPrompt);
            
            // Check if AI found something we missed
            boolean aiFoundVuln = verdict.toLowerCase().contains("vulnerable") || 
                                  verdict.toLowerCase().contains("exploitable") ||
                                  verdict.toLowerCase().contains("confirmed");
            
            if (aiFoundVuln && !verdict.toLowerCase().contains("not vulnerable") && 
                !verdict.toLowerCase().contains("not exploitable")) {
                resultCallback.accept(new AIExploitResult("SUCCESS", verdict,
                    null, null, null, 0, 0, true, verdict));
            } else {
                resultCallback.accept(new AIExploitResult("CONCLUSION", verdict,
                    null, null, null, 0, 0, false, verdict));
            }
        }
    }

    /**
     * Build expert-level analysis prompt - like a senior pentester would think.
     */
    private String buildExpertAnalysisPrompt(String userPrompt, String request, String response) {
        // Detect WAF first
        List<WAFDetector.WAFInfo> wafList = WAFDetector.detectWAF(response, response, extractStatusCode(response));
        String wafInfo = wafList.isEmpty() ? "No WAF detected" : WAFDetector.getBypassSuggestions(wafList);
        
        // Get systematic testing methodology
        String methodology = SystematicTestingEngine.getMethodology(userPrompt, request, response).toFormattedString();
        
        // Get bypass knowledge for this vulnerability type
        String bypassKnowledge = BypassKnowledgeBase.getBypassKnowledge(userPrompt);
        
        return """
            You are a senior offensive security expert with 15+ years of web application penetration testing experience.
            You follow systematic testing methodologies and use proven bypass techniques from PayloadsAllTheThings.
            
            USER'S GOAL: %s
            
            === REQUEST ===
            %s
            
            === RESPONSE ===
            %s
            
            === WAF DETECTION ===
            %s
            
            === SYSTEMATIC TESTING METHODOLOGY ===
            %s
            
            === BYPASS KNOWLEDGE BASE ===
            %s
            
            INSTRUCTIONS:
            1. Follow the systematic methodology step-by-step
            2. If WAF detected, use WAF-specific bypasses
            3. Reference the bypass knowledge base for proven techniques
            4. Be specific to THIS request context
            5. Provide actionable exploitation steps
            
            Provide expert analysis following this structure:
            
            1. **REQUEST ANALYSIS**
               - Endpoint purpose and functionality
               - Parameters and their types
               - Content-Type and data format
               - Interesting headers/cookies
            
            2. **SECURITY ASSESSMENT**
               - Input validation/sanitization detected
               - Error messages revealing technology
               - WAF/security controls present
               - Response patterns indicating processing
            
            3. **ATTACK SURFACE**
               - Most vulnerable parameters
               - Required encoding/bypass techniques
               - Context-specific attack vectors
            
            4. **EXPLOITATION STRATEGY**
               - Step-by-step approach (follow methodology)
               - Specific payloads for THIS context
               - Expected success indicators
               - WAF bypass techniques if needed
            
            Think like you're writing a professional pentest report with actionable steps.
            """.formatted(userPrompt, truncate(request, 2000), truncate(response, 1500), 
                         wafInfo, truncate(methodology, 3000), truncate(bypassKnowledge, 2000));
    }

    /**
     * Build payload generation prompt with context from previous attempts.
     */
    private String buildPayloadGenerationPrompt(String userPrompt, String request, String response,
                                                String analysis, List<TestResult> previousResults, int round) {
        StringBuilder previousAttempts = new StringBuilder();
        if (!previousResults.isEmpty()) {
            previousAttempts.append("\n\nPREVIOUS ATTEMPTS (learn from these):\n");
            for (int i = 0; i < Math.min(previousResults.size(), 10); i++) {
                TestResult r = previousResults.get(i);
                previousAttempts.append("- Payload: ").append(truncate(r.payload != null ? r.payload.value : "?", 50));
                previousAttempts.append(" ‚Üí Status: ").append(r.statusCode);
                previousAttempts.append(", Length: ").append(r.responseLength);
                if (r.redirectLocation != null) {
                    previousAttempts.append(", Redirected to: ").append(r.redirectLocation);
                }
                previousAttempts.append("\n");
            }
            previousAttempts.append("\nThese didn't work. Try DIFFERENT techniques from the bypass knowledge base!\n");
        }

        String roundStrategy = switch (round) {
            case 1 -> "Start with common attack patterns from PayloadsAllTheThings.";
            case 2 -> "Try encoding bypasses: URL encoding, double encoding, Unicode, HTML entities.";
            case 3 -> "Try advanced bypasses: case variation, null bytes, alternative syntax, WAF evasion.";
            default -> "Try creative/unusual payloads.";
        };
        
        // Get bypass knowledge for this round
        String bypassKnowledge = BypassKnowledgeBase.getBypassKnowledge(userPrompt);
        
        // Detect WAF for bypass suggestions
        List<WAFDetector.WAFInfo> wafList = WAFDetector.detectWAF(response, response, extractStatusCode(response));
        String wafBypasses = "";
        if (!wafList.isEmpty()) {
            wafBypasses = "\n\n=== WAF BYPASS TECHNIQUES ===\n" + WAFDetector.getBypassSuggestions(wafList);
        }

        return """
            You are an expert penetration tester with access to PayloadsAllTheThings knowledge base.
            
            TARGET: %s
            ROUND: %d/3 - %s
            
            YOUR ANALYSIS:
            %s
            %s
            %s
            
            === REQUEST TO ATTACK ===
            %s
            
            === BYPASS KNOWLEDGE BASE ===
            %s
            
            Generate 5-8 SPECIFIC payloads using techniques from the bypass knowledge base.
            For each payload, you MUST use this EXACT format:
            
            PAYLOAD_START
            PARAM: [exact parameter name from the request]
            VALUE: [the actual payload value to inject]
            WHY: [why this specific payload might work - reference bypass technique]
            SUCCESS: [what response would indicate success]
            PAYLOAD_END
            
            CRITICAL RULES:
            - Use ACTUAL parameter names from the request (not placeholders)
            - Reference specific bypass techniques from the knowledge base
            - If WAF detected, use WAF-specific bypasses
            - Each payload should try a DIFFERENT technique
            - Follow the systematic methodology
            
            Generate payloads NOW:
            """.formatted(userPrompt, round, roundStrategy, truncate(analysis, 600), 
                         previousAttempts.toString(), wafBypasses,
                         truncate(request, 1200), truncate(bypassKnowledge, 1500));
    }

    /**
     * Build verdict prompt for final analysis.
     */
    private String buildVerdictPrompt(String userPrompt, String request, List<TestResult> results) {
        StringBuilder resultsText = new StringBuilder();
        Map<Integer, Integer> statusCounts = new HashMap<>();
        Set<Integer> uniqueLengths = new HashSet<>();
        
        for (TestResult r : results) {
            statusCounts.merge(r.statusCode, 1, Integer::sum);
            uniqueLengths.add(r.responseLength);
            
            resultsText.append("Payload: ").append(r.payload != null ? truncate(r.payload.value, 60) : "?").append("\n");
            resultsText.append("  Status: ").append(r.statusCode).append(" | Length: ").append(r.responseLength);
            if (r.redirectLocation != null) {
                resultsText.append(" | Redirect: ").append(r.redirectLocation);
            }
            resultsText.append("\n");
            if (r.responseText != null && r.responseText.length() < 500) {
                // Check for interesting patterns in response
                if (r.responseText.toLowerCase().contains("error") || 
                    r.responseText.toLowerCase().contains("invalid") ||
                    r.responseText.toLowerCase().contains("denied")) {
                    resultsText.append("  Response hint: Contains error/validation message\n");
                }
            }
            resultsText.append("\n");
        }

        return """
            You are a senior penetration tester writing a professional assessment.
            
            ORIGINAL GOAL: %s
            
            REQUEST TESTED:
            %s
            
            TEST RESULTS SUMMARY:
            - Total payloads tested: %d
            - Status codes seen: %s
            - Unique response lengths: %d different lengths
            
            DETAILED RESULTS:
            %s
            
            Provide your EXPERT VERDICT:
            
            1. **EXPLOITABILITY ASSESSMENT**
               - Is this parameter/endpoint VULNERABLE or NOT VULNERABLE to %s?
               - Confidence level: HIGH / MEDIUM / LOW
            
            2. **EVIDENCE**
               - What specific observations support your conclusion?
               - Any response patterns that indicate security controls?
               - Did any payload cause interesting behavior?
            
            3. **SECURITY CONTROLS DETECTED**
               - What protections appear to be in place?
               - Input validation patterns observed?
               - WAF or filtering detected?
            
            4. **RECOMMENDATIONS**
               - If vulnerable: How to exploit further
               - If not vulnerable: Why it's protected and what else to try
            
            Be definitive. State clearly: "VULNERABLE" or "NOT VULNERABLE" with reasoning.
            """.formatted(userPrompt, truncate(request, 1000), results.size(), 
                         statusCounts.toString(), uniqueLengths.size(), 
                         resultsText.toString(), userPrompt);
    }

    /**
     * Parse payloads from AI response with context awareness.
     */
    private List<PayloadInfo> parsePayloads(String aiResponse, String originalRequest) {
        List<PayloadInfo> payloads = new ArrayList<>();
        
        // Extract parameters from original request for validation
        Set<String> requestParams = extractParameterNames(originalRequest);
        
        // Parse structured format
        Pattern pattern = Pattern.compile(
            "PAYLOAD_START\\s*\\n?" +
            "PARAM:\\s*(.+?)\\s*\\n" +
            "VALUE:\\s*(.+?)\\s*\\n" +
            "WHY:\\s*(.+?)\\s*\\n" +
            "SUCCESS:\\s*(.+?)\\s*\\n?" +
            "PAYLOAD_END",
            Pattern.DOTALL | Pattern.CASE_INSENSITIVE
        );
        
        Matcher matcher = pattern.matcher(aiResponse);
        while (matcher.find()) {
            PayloadInfo info = new PayloadInfo();
            info.parameter = matcher.group(1).trim();
            info.value = matcher.group(2).trim();
            info.description = matcher.group(3).trim();
            info.expected = matcher.group(4).trim();
            
            // Validate parameter exists or use first available
            if (!requestParams.contains(info.parameter) && !requestParams.isEmpty()) {
                // Try to find a close match
                for (String param : requestParams) {
                    if (param.toLowerCase().contains(info.parameter.toLowerCase()) ||
                        info.parameter.toLowerCase().contains(param.toLowerCase())) {
                        info.parameter = param;
                        break;
                    }
                }
            }
            
            payloads.add(info);
        }

        // Fallback: try simpler format
        if (payloads.isEmpty()) {
            Pattern simplePattern = Pattern.compile("PAYLOAD\\|([^|]+)\\|([^|]+)\\|([^|]+)\\|([^|\\n]+)");
            Matcher simpleMatcher = simplePattern.matcher(aiResponse);
            while (simpleMatcher.find()) {
                PayloadInfo info = new PayloadInfo();
                info.parameter = simpleMatcher.group(1).trim();
                info.value = simpleMatcher.group(2).trim();
                info.description = simpleMatcher.group(3).trim();
                info.expected = simpleMatcher.group(4).trim();
                payloads.add(info);
            }
        }

        // Last resort: extract from code blocks
        if (payloads.isEmpty() && !requestParams.isEmpty()) {
            String firstParam = requestParams.iterator().next();
            Pattern codePattern = Pattern.compile("`([^`]{2,100})`");
            Matcher codeMatcher = codePattern.matcher(aiResponse);
            int count = 0;
            while (codeMatcher.find() && count < 6) {
                String value = codeMatcher.group(1).trim();
                if (looksLikePayload(value)) {
                    PayloadInfo info = new PayloadInfo();
                    info.parameter = firstParam;
                    info.value = value;
                    info.description = "Extracted payload";
                    info.expected = "Different response";
                    payloads.add(info);
                    count++;
                }
            }
        }

        return payloads;
    }

    private Set<String> extractParameterNames(String request) {
        Set<String> params = new LinkedHashSet<>();
        
        // URL parameters
        Pattern urlPattern = Pattern.compile("[?&]([^=&\\s]+)=");
        Matcher urlMatcher = urlPattern.matcher(request);
        while (urlMatcher.find()) {
            params.add(urlMatcher.group(1));
        }
        
        // Body parameters (form data)
        int bodyStart = request.indexOf("\r\n\r\n");
        if (bodyStart > 0) {
            String body = request.substring(bodyStart + 4);
            
            // Form data
            Pattern formPattern = Pattern.compile("(^|&)([^=&]+)=");
            Matcher formMatcher = formPattern.matcher(body);
            while (formMatcher.find()) {
                String param = formMatcher.group(2).trim();
                if (!param.isEmpty() && !param.contains("{")) {
                    params.add(param);
                }
            }
            
            // JSON keys
            Pattern jsonPattern = Pattern.compile("\"([^\"]+)\"\\s*:");
            Matcher jsonMatcher = jsonPattern.matcher(body);
            while (jsonMatcher.find()) {
                params.add(jsonMatcher.group(1));
            }
        }
        
        return params;
    }

    private boolean looksLikePayload(String value) {
        return value.contains("'") || value.contains("\"") || value.contains("<") || 
               value.contains(">") || value.contains("../") || value.contains("..\\") ||
               value.contains(";") || value.contains("|") || value.contains("${") ||
               value.contains("{{") || value.contains("$(") || value.contains("`") ||
               value.matches(".*\\bOR\\b.*") || value.matches(".*\\bAND\\b.*") ||
               value.contains("UNION") || value.contains("SELECT");
    }

    /**
     * Execute a payload and collect detailed results.
     */
    private TestResult executePayload(IHttpRequestResponse baseRequest, PayloadInfo payload,
                                      String host, int port, boolean https) {
        TestResult result = new TestResult();
        result.payload = payload;

        try {
            byte[] modifiedRequest = buildModifiedRequest(baseRequest.getRequest(), payload);
            result.request = modifiedRequest;

            IHttpService service = baseRequest.getHttpService();
            long startTime = System.currentTimeMillis();
            byte[] responseBytes = null;

            try {
                IHttpRequestResponse response = callbacks.makeHttpRequest(service, modifiedRequest);
                if (response != null && response.getResponse() != null) {
                    responseBytes = response.getResponse();
                }
            } catch (Exception e) {
                responseBytes = makeHttpRequest(host, port, https, modifiedRequest);
            }

            result.responseTime = System.currentTimeMillis() - startTime;
            result.response = responseBytes;

            if (responseBytes != null && responseBytes.length > 0) {
                result.responseText = new String(responseBytes, java.nio.charset.StandardCharsets.UTF_8);
                result.statusCode = extractStatusCode(result.responseText);
                result.responseLength = responseBytes.length;
                
                // Follow redirects
                if (isRedirect(result.statusCode)) {
                    String location = extractHeader(result.responseText, "Location");
                    if (location != null) {
                        result.redirectLocation = location;
                        TestResult redirectResult = followRedirect(host, port, https, location);
                        if (redirectResult != null && redirectResult.responseText != null) {
                            result.redirectedResponse = redirectResult.response;
                            result.redirectedResponseText = redirectResult.responseText;
                            result.redirectedStatusCode = redirectResult.statusCode;
                        }
                    }
                }
            }

        } catch (Exception e) {
            result.error = e.getMessage();
        }

        return result;
    }

    private byte[] buildModifiedRequest(byte[] originalRequest, PayloadInfo payload) {
        String requestText = new String(originalRequest, java.nio.charset.StandardCharsets.UTF_8);
        String param = payload.parameter;
        String value = payload.value;
        
        // Try to replace in URL
        String urlPattern = "([?&])" + Pattern.quote(param) + "=([^&\\s]*)";
        if (requestText.matches("(?s).*" + urlPattern + ".*")) {
            requestText = requestText.replaceFirst(urlPattern, "$1" + param + "=" + urlEncode(value));
            return requestText.getBytes(java.nio.charset.StandardCharsets.UTF_8);
        }
        
        // Try to replace in body
        int bodyStart = requestText.indexOf("\r\n\r\n");
        if (bodyStart > 0) {
            String headers = requestText.substring(0, bodyStart + 4);
            String body = requestText.substring(bodyStart + 4);
            
            // Form data
            String bodyPattern = "(^|&)" + Pattern.quote(param) + "=([^&]*)";
            if (body.matches("(?s).*" + bodyPattern + ".*")) {
                body = body.replaceFirst(bodyPattern, "$1" + param + "=" + urlEncode(value));
                return (headers + body).getBytes(java.nio.charset.StandardCharsets.UTF_8);
            }
            
            // JSON
            String jsonPattern = "\"" + Pattern.quote(param) + "\"\\s*:\\s*\"[^\"]*\"";
            if (body.matches("(?s).*" + jsonPattern + ".*")) {
                body = body.replaceFirst(jsonPattern, "\"" + param + "\": \"" + escapeJson(value) + "\"");
                return (headers + body).getBytes(java.nio.charset.StandardCharsets.UTF_8);
            }
            
            // JSON number/boolean
            String jsonNumPattern = "\"" + Pattern.quote(param) + "\"\\s*:\\s*[^,}\\]]+";
            if (body.matches("(?s).*" + jsonNumPattern + ".*")) {
                body = body.replaceFirst(jsonNumPattern, "\"" + param + "\": \"" + escapeJson(value) + "\"");
                return (headers + body).getBytes(java.nio.charset.StandardCharsets.UTF_8);
            }
        }
        
        return requestText.getBytes(java.nio.charset.StandardCharsets.UTF_8);
    }

    /**
     * Check if response has interesting patterns worth AI verification.
     * This is a quick pre-filter before calling AI.
     */
    private boolean hasInterestingResponse(TestResult result, PayloadInfo payload) {
        if (result.responseText == null) return false;
        
        String response = result.responseText;
        String redirected = result.redirectedResponseText;
        String combined = response + (redirected != null ? redirected : "");
        String payloadValue = payload.value;
        
        // Check if any part of the payload appears in response (could be reflected)
        // Extract key parts of payload to check
        String[] payloadParts = extractPayloadParts(payloadValue);
        for (String part : payloadParts) {
            if (part.length() > 3 && combined.contains(part)) {
                return true; // Payload or part of it is reflected
            }
        }
        
        // Check for error messages that might indicate vulnerability
        String lower = combined.toLowerCase();
        if (lower.contains("error") || lower.contains("exception") || 
            lower.contains("warning") || lower.contains("syntax") ||
            lower.contains("invalid") || lower.contains("failed")) {
            return true;
        }
        
        // Check for significant response changes (different status or length)
        if (result.statusCode >= 500) return true; // Server error
        if (result.statusCode != 200 && result.statusCode != 302) return true; // Unusual status
        
        return false;
    }

    /**
     * Extract key parts of payload for reflection checking.
     */
    private String[] extractPayloadParts(String payload) {
        List<String> parts = new ArrayList<>();
        
        // Add the full payload
        parts.add(payload);
        
        // Extract content between tags
        Pattern tagContent = Pattern.compile(">([^<]+)<");
        Matcher m = tagContent.matcher(payload);
        while (m.find()) {
            String content = m.group(1).trim();
            if (content.length() > 3) parts.add(content);
        }
        
        // Extract alphanumeric sequences (like alert(12345))
        Pattern alphaNum = Pattern.compile("\\b([a-zA-Z]+\\([^)]+\\))");
        m = alphaNum.matcher(payload);
        while (m.find()) {
            parts.add(m.group(1));
        }
        
        // Extract numbers that might be markers
        Pattern numbers = Pattern.compile("\\b(\\d{4,})\\b");
        m = numbers.matcher(payload);
        while (m.find()) {
            parts.add(m.group(1));
        }
        
        return parts.toArray(new String[0]);
    }

    /**
     * AI-based verification of exploit success.
     * This is the key method that prevents false positives by having AI analyze
     * the response like a human pentester would.
     */
    private String verifyExploitWithAI(TestResult result, PayloadInfo payload, String userPrompt) {
        try {
            String responseSnippet = truncate(result.responseText, 2000);
            String redirectedSnippet = result.redirectedResponseText != null ? 
                truncate(result.redirectedResponseText, 1000) : "";
            
            String verificationPrompt = """
                You are a senior penetration tester verifying if a vulnerability is REAL or a FALSE POSITIVE.
                
                ATTACK TYPE: %s
                PAYLOAD SENT: %s
                EXPECTED SUCCESS INDICATOR: %s
                
                RESPONSE RECEIVED (Status: %d, Length: %d bytes):
                ```
                %s
                ```
                %s
                
                CRITICAL ANALYSIS REQUIRED:
                
                1. **REFLECTION CHECK**
                   - Is the payload reflected in the response?
                   - If reflected, is it ENCODED (safe) or UNENCODED (vulnerable)?
                   - Look for: &lt; &gt; &quot; &#39; &amp; - these indicate OUTPUT ENCODING (SAFE)
                   - Look for: < > " ' appearing as-is in HTML context (VULNERABLE)
                
                2. **EXECUTION CHECK**
                   - For XSS: Would this payload actually EXECUTE in a browser?
                   - For SQLi: Are there actual SQL error messages or data leakage?
                   - For Command Injection: Is there actual command output?
                   - For SSTI: Did the template expression evaluate?
                
                3. **CONTEXT CHECK**
                   - Where in the HTML/response does the reflection appear?
                   - Is it in a context where it could be dangerous?
                   - Is it inside a script tag, attribute, or HTML body?
                
                4. **VERDICT**
                   You MUST respond with ONE of these:
                   - "CONFIRMED VULNERABLE: [explanation of why it's exploitable]"
                   - "FALSE POSITIVE: [explanation of why it's NOT exploitable, e.g., output encoding, wrong context]"
                   - "NEEDS MORE TESTING: [what additional tests would confirm]"
                
                Be STRICT. Only say CONFIRMED if you are certain the payload would execute/work.
                If you see &lt; or &gt; or encoded characters, it's likely a FALSE POSITIVE.
                """.formatted(
                    userPrompt,
                    payload.value,
                    payload.expected,
                    result.statusCode,
                    result.responseLength,
                    responseSnippet,
                    redirectedSnippet.isEmpty() ? "" : "\nREDIRECTED RESPONSE:\n```\n" + redirectedSnippet + "\n```"
                );
            
            return callAI(verificationPrompt);
            
        } catch (Exception e) {
            return "Verification failed: " + e.getMessage();
        }
    }

    /**
     * Check for REAL exploitation success - avoid false positives from encoded output.
     * 
     * Key principle: A vulnerability exists only if the payload executes/works.
     * - XSS: payload must be reflected WITHOUT HTML encoding (< > " ' must not be encoded)
     * - SQLi: must see actual SQL error messages or behavior change
     * - etc.
     */
    private boolean checkForExploitSuccess(TestResult result, PayloadInfo payload) {
        // This method is now only used as a backup
        // Primary verification is done by AI in verifyExploitWithAI
        if (result.responseText == null) return false;
        
        String response = result.responseText;
        String redirectedResponse = result.redirectedResponseText;
        String combinedResponse = response + (redirectedResponse != null ? redirectedResponse : "");
        String lower = combinedResponse.toLowerCase();
        String payloadValue = payload.value;
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // XSS Detection - MUST check for UNENCODED reflection
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if (isXSSPayload(payloadValue)) {
            // Check if payload is reflected WITHOUT encoding
            if (isXSSReflectedUnencoded(combinedResponse, payloadValue)) {
                return true;
            }
            // If we find encoded version, it's NOT vulnerable - return false
            if (isXSSReflectedEncoded(combinedResponse, payloadValue)) {
                return false; // Explicitly NOT vulnerable - output encoding is working
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SQL Injection Detection - Look for actual SQL errors
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if (isSQLiPayload(payloadValue)) {
            // MySQL errors
            if (lower.contains("you have an error in your sql syntax") ||
                lower.contains("mysql_fetch") || lower.contains("mysql_query") ||
                lower.contains("mysqli_")) return true;
            
            // PostgreSQL errors
            if (lower.contains("pg_query") || lower.contains("pg_exec") ||
                lower.contains("unterminated quoted string") ||
                lower.contains("syntax error at or near")) return true;
            
            // Oracle errors
            if (lower.contains("ora-00") || lower.contains("ora-01") ||
                lower.contains("oracle error")) return true;
            
            // SQL Server errors
            if (lower.contains("unclosed quotation mark") ||
                lower.contains("incorrect syntax near") ||
                lower.contains("sqlserver")) return true;
            
            // SQLite errors
            if (lower.contains("sqlite3") || lower.contains("sqlite_") ||
                lower.contains("unrecognized token")) return true;
            
            // Generic SQL errors
            if (lower.contains("sql syntax") || lower.contains("sql error") ||
                lower.contains("database error") || lower.contains("odbc error")) return true;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Command Injection Detection
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Linux command output
        if (combinedResponse.contains("uid=") && combinedResponse.contains("gid=") && 
            combinedResponse.contains("groups=")) return true;
        if (combinedResponse.matches("(?s).*root:x:0:0:.*:/root:.*")) return true;
        
        // Windows command output
        if (combinedResponse.contains("Windows IP Configuration") ||
            combinedResponse.contains("Volume Serial Number") ||
            combinedResponse.contains("Directory of ")) return true;
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Path Traversal Detection
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if (combinedResponse.contains("[boot loader]") || 
            combinedResponse.contains("[operating systems]")) return true;
        if (combinedResponse.matches("(?s).*root:x:0:0:root:/root:.*")) return true;
        if (combinedResponse.contains("[extensions]") && 
            combinedResponse.contains("[fonts]")) return true;
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SSTI Detection - Check for actual template execution
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if (payloadValue.contains("{{") || payloadValue.contains("${")) {
            // Check if math was executed (e.g., {{7*7}} -> 49)
            if (payloadValue.contains("7*7") && combinedResponse.contains("49")) return true;
            if (payloadValue.contains("7*'7'") && combinedResponse.contains("7777777")) return true;
        }
        
        return false;
    }

    /**
     * Check if payload is an XSS payload.
     */
    private boolean isXSSPayload(String payload) {
        String lower = payload.toLowerCase();
        return lower.contains("<script") || lower.contains("onerror") || 
               lower.contains("onload") || lower.contains("onclick") ||
               lower.contains("javascript:") || lower.contains("<img") ||
               lower.contains("<svg") || lower.contains("<body") ||
               lower.contains("onfocus") || lower.contains("onmouseover");
    }

    /**
     * Extract a unique marker from XSS payload for verification.
     * E.g., from alert(12345) extract "12345"
     */
    private String extractXSSMarker(String payload) {
        // Look for alert/confirm/prompt with argument
        Pattern p = Pattern.compile("(alert|confirm|prompt)\\s*\\(\\s*['\"]?([^)'\"]+)['\"]?\\s*\\)");
        Matcher m = p.matcher(payload);
        if (m.find()) {
            return m.group(2).trim();
        }
        
        // Look for any number that could be a marker
        Pattern numPattern = Pattern.compile("\\b(\\d{4,})\\b");
        Matcher numMatcher = numPattern.matcher(payload);
        if (numMatcher.find()) {
            return numMatcher.group(1);
        }
        
        // Look for unique string in quotes
        Pattern strPattern = Pattern.compile("['\"]([^'\"]{3,20})['\"]");
        Matcher strMatcher = strPattern.matcher(payload);
        if (strMatcher.find()) {
            return strMatcher.group(1);
        }
        
        return "XSS";
    }

    /**
     * Extract HTML body from HTTP response for browser verification.
     */
    private String extractHtmlBody(String httpResponse) {
        if (httpResponse == null) return "";
        
        // Find the body after headers
        int bodyStart = httpResponse.indexOf("\r\n\r\n");
        if (bodyStart > 0) {
            return httpResponse.substring(bodyStart + 4);
        }
        
        bodyStart = httpResponse.indexOf("\n\n");
        if (bodyStart > 0) {
            return httpResponse.substring(bodyStart + 2);
        }
        
        // If no headers found, assume it's all body
        return httpResponse;
    }

    /**
     * Check if XSS payload is reflected WITHOUT encoding (actually vulnerable).
     */
    private boolean isXSSReflectedUnencoded(String response, String payload) {
        // For XSS to work, the EXACT payload with < > must appear unencoded
        // Check for the actual dangerous characters
        
        if (payload.contains("<script")) {
            // Must find <script> not &lt;script&gt;
            int idx = response.indexOf("<script");
            if (idx >= 0) {
                // Make sure it's not inside an HTML comment or encoded
                String before = idx > 10 ? response.substring(idx - 10, idx) : response.substring(0, idx);
                if (!before.contains("&lt;") && !before.contains("<!--")) {
                    return true;
                }
            }
        }
        
        if (payload.contains("<img") || payload.contains("<svg")) {
            String tag = payload.contains("<img") ? "<img" : "<svg";
            int idx = response.indexOf(tag);
            if (idx >= 0) {
                // Check if onerror/onload is also present unencoded
                String afterTag = response.substring(idx, Math.min(idx + 200, response.length()));
                if ((afterTag.contains("onerror=") || afterTag.contains("onload=")) &&
                    !afterTag.contains("&lt;") && !afterTag.contains("&gt;")) {
                    return true;
                }
            }
        }
        
        if (payload.toLowerCase().contains("javascript:")) {
            // Check for unencoded javascript: in href or src
            if (response.contains("href=\"javascript:") || 
                response.contains("href='javascript:") ||
                response.contains("src=\"javascript:") ||
                response.contains("src='javascript:")) {
                return true;
            }
        }
        
        // Check for event handlers reflected unencoded
        String[] eventHandlers = {"onerror=", "onload=", "onclick=", "onmouseover=", "onfocus="};
        for (String handler : eventHandlers) {
            if (payload.toLowerCase().contains(handler.replace("=", ""))) {
                // Must find the handler NOT encoded
                if (response.contains(handler) && !response.contains("on" + handler.substring(2))) {
                    // Additional check: make sure it's in an HTML context
                    int idx = response.indexOf(handler);
                    if (idx > 0) {
                        String before = response.substring(Math.max(0, idx - 50), idx);
                        // Should be inside a tag
                        if (before.contains("<") && !before.substring(before.lastIndexOf("<")).contains(">")) {
                            return true;
                        }
                    }
                }
            }
        }
        
        return false;
    }

    /**
     * Check if XSS payload is reflected but ENCODED (safe - not vulnerable).
     */
    private boolean isXSSReflectedEncoded(String response, String payload) {
        // Common HTML entity encodings that make XSS safe
        String[] dangerousChars = {"<", ">", "\"", "'"};
        String[] encodedVersions = {"&lt;", "&gt;", "&quot;", "&#39;", "&apos;", "&#x27;"};
        
        // Check if the payload content appears but with encoding
        String payloadContent = payload.replaceAll("<[^>]+>", "").trim(); // Get text content
        
        // If we find encoded versions of < or >, the output is being sanitized
        for (String encoded : encodedVersions) {
            if (response.contains(encoded)) {
                // Check if our payload's dangerous chars are being encoded
                if (payload.contains("<") && response.contains("&lt;")) return true;
                if (payload.contains(">") && response.contains("&gt;")) return true;
            }
        }
        
        // Check for the specific pattern: encoded script tags
        if (payload.toLowerCase().contains("<script") && 
            (response.contains("&lt;script") || response.contains("&#60;script"))) {
            return true;
        }
        
        return false;
    }

    /**
     * Check if payload is a SQL injection payload.
     */
    private boolean isSQLiPayload(String payload) {
        String lower = payload.toLowerCase();
        return lower.contains("'") || lower.contains("\"") ||
               lower.contains(" or ") || lower.contains(" and ") ||
               lower.contains("union") || lower.contains("select") ||
               lower.contains("--") || lower.contains("/*") ||
               lower.contains("sleep(") || lower.contains("waitfor") ||
               lower.contains("benchmark(");
    }

    private String buildTestStatus(TestResult result) {
        StringBuilder sb = new StringBuilder();
        sb.append("‚Üí ").append(result.statusCode);
        sb.append(" | ").append(result.responseLength).append(" bytes");
        sb.append(" | ").append(result.responseTime).append("ms");
        
        if (result.redirectLocation != null) {
            sb.append(" ‚Üí Redirect: ").append(truncate(result.redirectLocation, 40));
            if (result.redirectedStatusCode > 0) {
                sb.append(" (").append(result.redirectedStatusCode).append(")");
            }
        }
        
        return sb.toString();
    }

    private String buildSuccessEvidence(TestResult result, PayloadInfo payload) {
        StringBuilder sb = new StringBuilder();
        sb.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        sb.append("POTENTIAL VULNERABILITY DETECTED\n");
        sb.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");
        sb.append("Parameter: ").append(payload.parameter).append("\n");
        sb.append("Payload: ").append(payload.value).append("\n");
        sb.append("Technique: ").append(payload.description).append("\n\n");
        sb.append("Response: ").append(result.statusCode).append(" (").append(result.responseLength).append(" bytes)\n");
        if (result.redirectLocation != null) {
            sb.append("Redirected to: ").append(result.redirectLocation).append("\n");
        }
        sb.append("\nExpected indicator: ").append(payload.expected).append("\n");
        return sb.toString();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HTTP Utilities
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    private boolean isRedirect(int statusCode) {
        return statusCode == 301 || statusCode == 302 || statusCode == 303 || 
               statusCode == 307 || statusCode == 308;
    }

    private TestResult followRedirect(String host, int port, boolean https, String location) {
        try {
            TestResult result = new TestResult();
            
            String targetHost = host;
            int targetPort = port;
            String targetPath = location;
            boolean targetHttps = https;
            
            if (location.startsWith("http://") || location.startsWith("https://")) {
                java.net.URL url = new java.net.URL(location);
                targetHost = url.getHost();
                targetPort = url.getPort() == -1 ? (url.getProtocol().equals("https") ? 443 : 80) : url.getPort();
                targetPath = url.getPath() + (url.getQuery() != null ? "?" + url.getQuery() : "");
                targetHttps = url.getProtocol().equals("https");
            }
            
            String redirectRequest = "GET " + targetPath + " HTTP/1.1\r\n" +
                "Host: " + targetHost + "\r\n" +
                "Connection: close\r\n\r\n";
            
            byte[] responseBytes = makeHttpRequest(targetHost, targetPort, targetHttps, 
                redirectRequest.getBytes(java.nio.charset.StandardCharsets.UTF_8));
            
            if (responseBytes != null) {
                result.response = responseBytes;
                result.responseText = new String(responseBytes, java.nio.charset.StandardCharsets.UTF_8);
                result.statusCode = extractStatusCode(result.responseText);
                result.responseLength = responseBytes.length;
            }
            
            return result;
        } catch (Exception e) {
            return null;
        }
    }

    private String extractHeader(String response, String headerName) {
        for (String line : response.split("\r?\n")) {
            if (line.isEmpty()) break;
            if (line.toLowerCase().startsWith(headerName.toLowerCase() + ":")) {
                return line.substring(headerName.length() + 1).trim();
            }
        }
        return null;
    }

    private String extractHost(String request) {
        String host = extractHeader(request, "Host");
        return host != null ? host.split(":")[0] : "localhost";
    }

    private byte[] makeHttpRequest(String host, int port, boolean https, byte[] request) throws Exception {
        String requestText = new String(request, java.nio.charset.StandardCharsets.UTF_8);
        String[] lines = requestText.split("\r\n");
        String[] firstLineParts = lines[0].split(" ");
        String method = firstLineParts[0];
        String path = firstLineParts.length > 1 ? firstLineParts[1] : "/";

        java.net.URL url = new java.net.URL(https ? "https" : "http", host, port, path);
        java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();
        conn.setRequestMethod(method);
        conn.setConnectTimeout(10000);
        conn.setReadTimeout(10000);
        conn.setInstanceFollowRedirects(false);

        for (int i = 1; i < lines.length; i++) {
            String line = lines[i];
            if (line.isEmpty()) break;
            int colonIdx = line.indexOf(':');
            if (colonIdx > 0) {
                String headerName = line.substring(0, colonIdx).trim();
                String headerValue = line.substring(colonIdx + 1).trim();
                if (!headerName.equalsIgnoreCase("Host") && !headerName.equalsIgnoreCase("Content-Length")) {
                    conn.setRequestProperty(headerName, headerValue);
                }
            }
        }

        int bodyStart = requestText.indexOf("\r\n\r\n");
        if (bodyStart > 0 && bodyStart + 4 < requestText.length()) {
            String body = requestText.substring(bodyStart + 4);
            if (!body.isEmpty()) {
                conn.setDoOutput(true);
                try (java.io.OutputStream os = conn.getOutputStream()) {
                    os.write(body.getBytes(java.nio.charset.StandardCharsets.UTF_8));
                }
            }
        }

        StringBuilder responseBuilder = new StringBuilder();
        responseBuilder.append("HTTP/1.1 ").append(conn.getResponseCode()).append(" ")
                      .append(conn.getResponseMessage()).append("\r\n");

        for (Map.Entry<String, java.util.List<String>> entry : conn.getHeaderFields().entrySet()) {
            if (entry.getKey() != null) {
                for (String value : entry.getValue()) {
                    responseBuilder.append(entry.getKey()).append(": ").append(value).append("\r\n");
                }
            }
        }
        responseBuilder.append("\r\n");

        java.io.InputStream is = null;
        try { is = conn.getInputStream(); } 
        catch (java.io.IOException e) { is = conn.getErrorStream(); }

        if (is != null) {
            byte[] buffer = new byte[8192];
            int bytesRead;
            java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
            while ((bytesRead = is.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesRead);
            }
            responseBuilder.append(baos.toString(java.nio.charset.StandardCharsets.UTF_8));
            is.close();
        }

        return responseBuilder.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8);
    }

    private int extractStatusCode(String response) {
        try {
            String[] parts = response.split("\r?\n")[0].split(" ");
            return parts.length >= 2 ? Integer.parseInt(parts[1]) : 0;
        } catch (Exception e) { return 0; }
    }

    private String callAI(String prompt) throws Exception {
        AIConfigManager config = AIConfigManager.getInstance();
        
        if ("Azure AI".equalsIgnoreCase(config.getProvider())) {
            AzureAIService.Configuration c = new AzureAIService.Configuration();
            c.setEndpoint(config.getEndpoint());
            c.setDeploymentName(config.getDeployment());
            c.setApiKey(config.getApiKey());
            c.setTemperature(config.getTemperature());
            return new AzureAIService(c).ask(
                "You are an expert offensive security professional.", prompt);
        } else {
            OpenAIService.Configuration c = new OpenAIService.Configuration();
            c.setApiKey(config.getApiKey());
            c.setModel(config.getModel());
            c.setTemperature(config.getTemperature());
            return new OpenAIService(c).ask(
                "You are an expert offensive security professional.", prompt);
        }
    }

    private String urlEncode(String s) {
        try { return java.net.URLEncoder.encode(s, "UTF-8"); } 
        catch (Exception e) { return s; }
    }

    private String escapeJson(String s) {
        return s.replace("\\", "\\\\").replace("\"", "\\\"")
                .replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
    }

    private String truncate(String s, int max) {
        if (s == null) return "";
        return s.length() > max ? s.substring(0, max) + "..." : s;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Data Classes
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    private static class PayloadInfo {
        String parameter;
        String value;
        String description;
        String expected;
    }

    private static class TestResult {
        PayloadInfo payload;
        byte[] request;
        byte[] response;
        String responseText;
        int statusCode;
        int responseLength;
        long responseTime;
        String error;
        String redirectLocation;
        byte[] redirectedResponse;
        String redirectedResponseText;
        int redirectedStatusCode;
    }
}
